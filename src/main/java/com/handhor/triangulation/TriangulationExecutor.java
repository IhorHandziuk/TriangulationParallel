//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.handhor.triangulation;import com.aparapi.Kernel;import com.aparapi.Range;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.LinkedList;import java.util.List;import java.util.Set;public class TriangulationExecutor {    private volatile Vertex[] vertices;    private volatile List<Set<Vertex>> frontVertices;    private Kernel initialKernel = new Kernel() {        public void run() {            int i = this.getGlobalId();            Vertex first = TriangulationExecutor.this.vertices[3 * i];            Vertex second = TriangulationExecutor.this.vertices[3 * i + 1];            Vertex third = TriangulationExecutor.this.vertices[3 * i + 2];            first.neig.add(second);            first.neig.add(third);            second.neig.add(first);            second.neig.add(third);            third.neig.add(first);            third.neig.add(second);            first.isBack = true;            third.isFront = true;            first.isFront = !first.isBetween(second, third);            third.isBack = !third.isBetween(first, second);            if (!second.isBetween(first, third)) {                second.isFront = true;                second.isBack = true;            } else {                float positionY = (second.x - first.x) / (third.x - first.x) * (third.y - first.y) + first.y;                float k = (third.y - first.y) / (third.x - first.x);                second.isFront = (second.y - positionY) * k < 0.0F;                second.isBack = !second.isFront;            }        }    };    private Kernel fillingKernel = new Kernel() {        public void run() {            int i = this.getGlobalId();            if (i != 0) {                List<Vertex> backVertices = new ArrayList();                if (TriangulationExecutor.this.vertices[3 * i].isBack) {                    backVertices.add(TriangulationExecutor.this.vertices[3 * i]);                }                if (TriangulationExecutor.this.vertices[3 * i + 1].isBack) {                    backVertices.add(TriangulationExecutor.this.vertices[3 * i + 1]);                }                if (TriangulationExecutor.this.vertices[3 * i + 2].isBack) {                    backVertices.add(TriangulationExecutor.this.vertices[3 * i + 2]);                }                List<Vertex> currFrontVertices = new ArrayList();                currFrontVertices.addAll((Collection)TriangulationExecutor.this.frontVertices.get(i - 1));                TriangulationExecutor.this.addCorrectLinks(currFrontVertices, backVertices);            }        }    };    public TriangulationExecutor(Vertex[] vertices) throws Exception {        this.vertices = vertices;        if (vertices.length % 3 != 0) {            throw new Exception("Number of vertices shold be divisible by 3");        } else {            Arrays.sort(vertices);            this.frontVertices = new ArrayList(vertices.length / 3);            for(int i = 0; i < vertices.length / 3; ++i) {                this.frontVertices.add(new HashSet());            }        }    }    public void execute() {        Range range = Range.create(this.vertices.length / 3);        this.initialKernel.execute(range);        this.computeFrontVertices();        this.fillingKernel.execute(range);    }    private float getAngle(Vertex vectorBegin, Vertex vectorEnd, Vertex point) {        Vector vecF = new Vector(vectorBegin, vectorEnd);        Vector vecS = new Vector(point, vectorBegin);        return (float)Math.acos((double)vecF.scalarProduct(vecS));    }    private Set<Vertex> convexUnion(Set<Vertex> prevSet, Set<Vertex> toAddSet) {        Set<Vertex> workingSet = new HashSet(prevSet);        workingSet.addAll(toAddSet);        Set<Vertex> result = new HashSet();        Vertex maxV = Collections.max(workingSet, Vertex.yComparator.reversed());        Vertex pointOnHull = maxV;        result.add(maxV);        Vertex rightPoint = new Vertex(maxV.x - 100.0F, maxV.y);        Vector rightVec = new Vector(-100.0F, 0.0F);        float minAngel = 3.15F;        Vertex pointWithMinAngel = (Vertex)Collections.min(workingSet, Vertex.yComparator.reversed());        do {            Iterator var11 = workingSet.iterator();            while(var11.hasNext()) {                Vertex it = (Vertex)var11.next();                if (this.getAngle(pointOnHull, rightPoint, it) < minAngel) {                    minAngel = this.getAngle(pointOnHull, rightPoint, it);                    pointWithMinAngel = it;                }            }            Vector v = new Vector(pointOnHull, pointWithMinAngel);            double k = Math.atan2((double)(v.y - rightVec.y), (double)(v.x - rightVec.x));            if (k > 0.0D) {                break;            }            pointOnHull.neig.add(pointWithMinAngel);            pointWithMinAngel.neig.add(pointOnHull);            result.add(pointWithMinAngel);            rightPoint = pointOnHull;            pointOnHull = pointWithMinAngel;            minAngel = 3.15F;        } while(pointWithMinAngel != maxV);        return result;    }    private void computeFrontVertices() {        int setsNum = this.frontVertices.size();        Set<Vertex> firstSet = (Set)this.frontVertices.get(0);        if (this.vertices[0].isFront) {            firstSet.add(this.vertices[0]);        }        if (this.vertices[1].isFront) {            firstSet.add(this.vertices[1]);        }        if (this.vertices[2].isFront) {            firstSet.add(this.vertices[2]);        }        for(int i = 1; i < setsNum; ++i) {            Set<Vertex> curFronts = new HashSet();            if (this.vertices[3 * i].isFront) {                curFronts.add(this.vertices[3 * i]);            }            if (this.vertices[3 * i + 1].isFront) {                curFronts.add(this.vertices[3 * i + 1]);            }            if (this.vertices[3 * i + 2].isFront) {                curFronts.add(this.vertices[3 * i + 2]);            }            Set<Vertex> newHull = this.convexUnion((Set)this.frontVertices.get(i - 1), curFronts);            this.frontVertices.set(i, newHull);        }    }    private boolean checkAngles(Vertex source, Vertex curr, Vertex next, boolean down) {        if (curr.y > source.y && source.y > next.y) {            return down;        } else {            Vector horizontal = new Vector(-100.0F, 0.0F);            Vector toCurr = new Vector(source, curr);            Vector toNext = new Vector(source, next);            return horizontal.scalarProduct(toCurr) > horizontal.scalarProduct(toNext);        }    }    private boolean isPossibleToReach(Vertex source, Vertex target, List<Vertex> back) {        List<Vertex> otherBack = new LinkedList(back);        otherBack.remove(source);        Iterator var5 = otherBack.iterator();        while(var5.hasNext()) {            Vertex v = (Vertex)var5.next();            if (v.x < source.x) {                if (v.y > source.y) {                    if (target.y > (target.x - v.x) / (source.x - v.x) * (source.y - v.y) + v.y) {                        return false;                    }                } else if (target.y < (target.x - v.x) / (source.x - v.x) * (source.y - v.y) + v.y) {                    return false;                }            }        }        return true;    }    private void addCorrectLinks(List<Vertex> front, List<Vertex> back) {        Collections.sort(front, Vertex.yComparator);        Collections.sort(back, Vertex.yComparator);        int i = 1;        Iterator var4 = back.iterator();        while(var4.hasNext()) {            Vertex backV = (Vertex)var4.next();            --i;            for(; i < front.size(); ++i) {                Vertex frontV = (Vertex)front.get(i);                if (!this.isPossibleToReach(backV, frontV, back)) {                    break;                }                if (frontV.y > backV.y) {                    if (i + 1 >= front.size() || !this.checkAngles(backV, frontV, (Vertex)front.get(i + 1), false)) {                        frontV.neig.add(backV);                        backV.neig.add(frontV);                    }                } else {                    if (i - 1 >= 0 && !this.checkAngles(backV, (Vertex)front.get(i - 1), frontV, true)) {                        break;                    }                    frontV.neig.add(backV);                    backV.neig.add(frontV);                }            }        }    }}