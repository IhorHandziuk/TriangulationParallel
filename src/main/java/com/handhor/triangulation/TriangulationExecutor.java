package com.handhor.triangulation;import com.aparapi.Kernel;import com.aparapi.Range;import java.util.*;public class TriangulationExecutor {    private volatile Vertex[] vertices;    private volatile List<Set<Vertex>> frontVertices;    private Kernel initialKernel = new Kernel() {        @Override        public void run() {            int i = getGlobalId();            Vertex first = vertices[3 * i];            Vertex second = vertices[3 * i + 1];            Vertex third = vertices[3 * i + 2];            //add links in current triangle            first.neig.add(second);            first.neig.add(third);            second.neig.add(first);            second.neig.add(third);            third.neig.add(first);            third.neig.add(second);            //set isFront and isBack flags            first.isBack = true;            third.isFront = true;            first.isFront = !first.isBetween(second, third);            third.isBack = !third.isBetween(first, second);            if (!second.isBetween(first, third)) {                second.isFront = true;                second.isBack = true;            } else {                float positionY = ((second.x - first.x) / (third.x - first.x)) * (third.y - first.y) + first.y;                float k = (third.y - first.y)/(third.x - first.x); //line's tangent                second.isFront = ((second.y - positionY) * k) < 0;                second.isBack = !second.isFront;            }        }    };    private Kernel fillingKernel = new Kernel() {        @Override        public void run() {            int i = getGlobalId();            if (i == 0) return;            List<Vertex> backVertices = new ArrayList<>();            if(vertices[3 * i].isBack) backVertices.add(vertices[3 * i]);            if(vertices[3 * i + 1].isBack) backVertices.add(vertices[3 * i + 1]);            if(vertices[3 * i + 2].isBack) backVertices.add(vertices[3 * i + 2]);            List<Vertex> currFrontVertices = new ArrayList<>();            currFrontVertices.addAll(frontVertices.get(i - 1));            addCorrectLinks(currFrontVertices, backVertices);        }    };    //Vertices length should be divisible by 3    public TriangulationExecutor(Vertex[] vertices) throws Exception {        this.vertices = vertices;        if (vertices.length % 3 != 0) {            throw new Exception("Number of vertices should be divisible by 3");        }        Arrays.sort(vertices);        frontVertices = new ArrayList<>(vertices.length / 3);        for (int i = 0; i < vertices.length / 3; i++) {            frontVertices.add(new HashSet<>());        }    }    //The main algorithm    public void execute() {        Range range = Range.create(vertices.length / 3);        initialKernel.execute(range);        computeFrontVertices();        fillingKernel.execute(range);    }    private float getAngle(Vertex vectorBegin, Vertex vectorEnd, Vertex point) {        Vector vecF = new Vector(vectorBegin, vectorEnd);        Vector vecS = new Vector(point, vectorBegin);        return (float)Math.acos(vecF.scalarProduct(vecS));    }    private Set<Vertex> convexUnion(Set<Vertex> prevSet, Set<Vertex> toAddSet) {        Set<Vertex> workingSet = new HashSet<>(prevSet);        workingSet.addAll(toAddSet);        Set<Vertex> result = new HashSet<>();        Vertex maxV = Collections.max(workingSet, Vertex.yComparator.reversed());        Vertex pointOnHull = maxV;        result.add(pointOnHull);        Vertex rightPoint = new Vertex(pointOnHull.x - 100, pointOnHull.y);        Vector rightVec = new Vector(-100, 0);        float minAngel = 3.15f;        Vertex pointWithMinAngel = Collections.min(workingSet, Vertex.yComparator.reversed());;        do {            for (Vertex it : workingSet) {                if (getAngle(pointOnHull, rightPoint, it) < minAngel) {                    minAngel = getAngle(pointOnHull, rightPoint, it);                    pointWithMinAngel = it;                }            }            Vector v = new Vector(pointOnHull, pointWithMinAngel);            double k = Math.atan2(v.y - rightVec.y, v.x - rightVec.x);            if (k > 0) break;            result.add(pointWithMinAngel);            rightPoint = pointOnHull;            pointOnHull = pointWithMinAngel;            minAngel = 3.15f;        } while (pointOnHull != maxV);        return result;    }    private void computeFrontVertices() {        int setsNum = frontVertices.size();        Set<Vertex> firstSet = frontVertices.get(0);        if(vertices[0].isFront) firstSet.add(vertices[0]);        if(vertices[1].isFront) firstSet.add(vertices[1]);        if(vertices[2].isFront) firstSet.add(vertices[2]);        for (int i = 1; i < setsNum; i++) {            Set<Vertex> curFronts = new HashSet<>();            if(vertices[3 * i].isFront) curFronts.add(vertices[3 * i]);            if(vertices[3 * i + 1].isFront) curFronts.add(vertices[3 * i + 1]);            if(vertices[3 * i + 2].isFront) curFronts.add(vertices[3 * i + 2]);            Set<Vertex> newHull = convexUnion(frontVertices.get(i-1), curFronts);            frontVertices.set(i, newHull);        }    }    //checks if ray to next vertex is higher than ray to current    private boolean checkAngles(Vertex source, Vertex curr, Vertex next, boolean down) {        if (curr.y > source.y && source.y > next.y) return down;        Vector horizontal = new Vector(-100, 0);        Vector toCurr = new Vector(source, curr);        Vector toNext = new Vector(source, next);        return horizontal.scalarProduct(toCurr) > horizontal.scalarProduct(toNext);    }    //checks if it is possible to reach target from source (considering only back vertices)    private boolean isPossibleToReach(Vertex source, Vertex target, List<Vertex> back) {        List<Vertex> otherBack = new LinkedList<>(back);        otherBack.remove(source);        for (Vertex v : otherBack) {            if (v.x < source.x) {                if (v.y > source.y) {                    //put target in line equality                    if (target.y > (((target.x - v.x) / (source.x - v.x)) * (source.y - v.y) + v.y)) {                        return false;                    }                } else {                    if (target.y < (((target.x - v.x) / (source.x - v.x)) * (source.y - v.y) + v.y)) {                        return false;                    }                }            }        }        return true;    }    private void addCorrectLinks(List<Vertex> front, List<Vertex> back) {        Collections.sort(front, Vertex.yComparator);        Collections.sort(back, Vertex.yComparator);        int i = 1;        for (Vertex backV : back) {            i--;            for (;i < front.size(); i++) {                Vertex frontV = front.get(i);                if (isPossibleToReach(backV, frontV, back)) {                    if (frontV.y > backV.y) {                        if(i + 1 < front.size() && checkAngles(backV, frontV, front.get(i + 1), false)) {                            continue;                        } else {                            frontV.neig.add(backV);                            backV.neig.add(frontV);                        }                    } else {                        if(i - 1 >= 0 && !checkAngles(backV, front.get(i - 1), frontV, true)) {                            break;                        } else {                            frontV.neig.add(backV);                            backV.neig.add(frontV);                        }                    }                } else break;            }        }    }}